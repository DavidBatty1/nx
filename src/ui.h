//----------------------------------------------------------------------------------------------------------------------
// Emulator UI
// Similar to the ZX Spectrum display model: monochrome pixels with 8x8 attributes.  Attribute 0xff, will be interpreted
// as transparent.  Also resolution fits the entire window and each pixel is 2x2 desktop pixels.
//----------------------------------------------------------------------------------------------------------------------

#pragma once

static const int kUiWidth = kWindowWidth * 2;
static const int kUiHeight = kWindowHeight * 2;

class Memory;
class Z80;
class Io;

class Ui
{
public:
    Ui(u32* img, Memory& memory, Z80& z80, Io& io);

    class Draw
    {
        friend class Ui;

    public:
        Draw(std::vector<u8>& pixels, std::vector<u8>& attr);

        //
        // Level 0 - poking
        //
        void pokePixel(int xCell, int yPixel, u8 bits);
        void andPixel(int xCell, int yPixel, u8 bits);
        void orPixel(int xCell, int yPixel, u8 bits);
        void xorPixel(int xCell, int yPixel, u8 bits);
        void pokeAttr(int xCell, int yCell, u8 attr);

        //
        // Level 1 - character rendering
        //
        void printChar(int xCell, int yCell, char c, u8 attr, const u8* font);
        int printChar(int xPixel, int yCell, char c, const u8* font);        // X is in pixels, returns width of character
        void printString(int xCell, int yCell, const char* str, u8 attr, const u8* font);
        void printSquashedString(int xCell, int yCell, const char* str, u8 attr, const u8* font);

    private:
        std::vector<u8>&    m_pixels;
        std::vector<u8>&    m_attrs;
    };

    // Clear the screen
    void clear();

    // Render the screen
    void render(std::function<void(Ui::Draw&)> draw);

private:
    u32*                m_image;
    std::vector<u8>     m_pixels;
    std::vector<u8>     m_attrs;
    Memory&             m_memory;
    Z80&                m_z80;
    Io&                 m_io;
};

//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------

#ifdef NX_IMPL

#include <cassert>

//----------------------------------------------------------------------------------------------------------------------
// Font
//----------------------------------------------------------------------------------------------------------------------

const u8 gFont[768] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10,
    0x10, 0x10, 0x00, 0x10, 0x00, 0x00, 0x24, 0x24, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x24, 0x7e, 0x24, 0x24, 0x7e, 0x24, 0x00, 0x00,
    0x08, 0x3e, 0x28, 0x3e, 0x0a, 0x3e, 0x08, 0x00, 0x62, 0x64, 0x08,
    0x10, 0x26, 0x46, 0x00, 0x00, 0x10, 0x28, 0x10, 0x2a, 0x44, 0x3a,
    0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
    0x08, 0x08, 0x08, 0x08, 0x04, 0x00, 0x00, 0x20, 0x10, 0x10, 0x10,
    0x10, 0x20, 0x00, 0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00,
    0x00, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
    0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x3c, 0x46, 0x4a,
    0x52, 0x62, 0x3c, 0x00, 0x00, 0x18, 0x28, 0x08, 0x08, 0x08, 0x3e,
    0x00, 0x00, 0x3c, 0x42, 0x02, 0x3c, 0x40, 0x7e, 0x00, 0x00, 0x3c,
    0x42, 0x0c, 0x02, 0x42, 0x3c, 0x00, 0x00, 0x08, 0x18, 0x28, 0x48,
    0x7e, 0x08, 0x00, 0x00, 0x7e, 0x40, 0x7c, 0x02, 0x42, 0x3c, 0x00,
    0x00, 0x3c, 0x40, 0x7c, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x7e, 0x02,
    0x04, 0x08, 0x10, 0x10, 0x00, 0x00, 0x3c, 0x42, 0x3c, 0x42, 0x42,
    0x3c, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x3e, 0x02, 0x3c, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00,
    0x00, 0x10, 0x10, 0x20, 0x00, 0x00, 0x04, 0x08, 0x10, 0x08, 0x04,
    0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x08, 0x04, 0x08, 0x10, 0x00, 0x00, 0x3c, 0x42, 0x04, 0x08,
    0x00, 0x08, 0x00, 0x00, 0x3c, 0x4a, 0x56, 0x5e, 0x40, 0x3c, 0x00,
    0x00, 0x3c, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x00, 0x00, 0x7c, 0x42,
    0x7c, 0x42, 0x42, 0x7c, 0x00, 0x00, 0x3c, 0x42, 0x40, 0x40, 0x42,
    0x3c, 0x00, 0x00, 0x78, 0x44, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00,
    0x7e, 0x40, 0x7c, 0x40, 0x40, 0x7e, 0x00, 0x00, 0x7e, 0x40, 0x7c,
    0x40, 0x40, 0x40, 0x00, 0x00, 0x3c, 0x42, 0x40, 0x4e, 0x42, 0x3c,
    0x00, 0x00, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42, 0x00, 0x00, 0x3e,
    0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x02, 0x02, 0x02, 0x42,
    0x42, 0x3c, 0x00, 0x00, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00,
    0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7e, 0x00, 0x00, 0x42, 0x66,
    0x5a, 0x42, 0x42, 0x42, 0x00, 0x00, 0x42, 0x62, 0x52, 0x4a, 0x46,
    0x42, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00,
    0x7c, 0x42, 0x42, 0x7c, 0x40, 0x40, 0x00, 0x00, 0x3c, 0x42, 0x42,
    0x52, 0x4a, 0x3c, 0x00, 0x00, 0x7c, 0x42, 0x42, 0x7c, 0x44, 0x42,
    0x00, 0x00, 0x3c, 0x40, 0x3c, 0x02, 0x42, 0x3c, 0x00, 0x00, 0xfe,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42,
    0x42, 0x3c, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00,
    0x00, 0x42, 0x42, 0x42, 0x42, 0x5a, 0x24, 0x00, 0x00, 0x42, 0x24,
    0x18, 0x18, 0x24, 0x42, 0x00, 0x00, 0x82, 0x44, 0x28, 0x10, 0x10,
    0x10, 0x00, 0x00, 0x7e, 0x04, 0x08, 0x10, 0x20, 0x7e, 0x00, 0x00,
    0x0e, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00, 0x00, 0x00, 0x40, 0x20,
    0x10, 0x08, 0x04, 0x00, 0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x70,
    0x00, 0x00, 0x10, 0x38, 0x54, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x1c, 0x22, 0x78, 0x20,
    0x20, 0x7e, 0x00, 0x00, 0x00, 0x38, 0x04, 0x3c, 0x44, 0x3c, 0x00,
    0x00, 0x20, 0x20, 0x3c, 0x22, 0x22, 0x3c, 0x00, 0x00, 0x00, 0x1c,
    0x20, 0x20, 0x20, 0x1c, 0x00, 0x00, 0x04, 0x04, 0x3c, 0x44, 0x44,
    0x3c, 0x00, 0x00, 0x00, 0x38, 0x44, 0x78, 0x40, 0x3c, 0x00, 0x00,
    0x0c, 0x10, 0x18, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x3c, 0x44,
    0x44, 0x3c, 0x04, 0x38, 0x00, 0x40, 0x40, 0x78, 0x44, 0x44, 0x44,
    0x00, 0x00, 0x10, 0x00, 0x30, 0x10, 0x10, 0x38, 0x00, 0x00, 0x04,
    0x00, 0x04, 0x04, 0x04, 0x24, 0x18, 0x00, 0x20, 0x28, 0x30, 0x30,
    0x28, 0x24, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0c, 0x00,
    0x00, 0x00, 0x68, 0x54, 0x54, 0x54, 0x54, 0x00, 0x00, 0x00, 0x78,
    0x44, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00, 0x38, 0x44, 0x44, 0x44,
    0x38, 0x00, 0x00, 0x00, 0x78, 0x44, 0x44, 0x78, 0x40, 0x40, 0x00,
    0x00, 0x3c, 0x44, 0x44, 0x3c, 0x04, 0x06, 0x00, 0x00, 0x1c, 0x20,
    0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x38, 0x40, 0x38, 0x04, 0x78,
    0x00, 0x00, 0x10, 0x38, 0x10, 0x10, 0x10, 0x0c, 0x00, 0x00, 0x00,
    0x44, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00, 0x44, 0x44, 0x28,
    0x28, 0x10, 0x00, 0x00, 0x00, 0x44, 0x54, 0x54, 0x54, 0x28, 0x00,
    0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x44,
    0x44, 0x44, 0x3c, 0x04, 0x38, 0x00, 0x00, 0x7c, 0x08, 0x10, 0x20,
    0x7c, 0x00, 0x00, 0x0e, 0x08, 0x30, 0x08, 0x08, 0x0e, 0x00, 0x00,
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x70, 0x10, 0x0c,
    0x10, 0x10, 0x70, 0x00, 0x00, 0x14, 0x28, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3c, 0x42, 0x99, 0xa1, 0xa1, 0x99, 0x42, 0x3c
};

const int gFontLength = 768;


//----------------------------------------------------------------------------------------------------------------------
// Ui
//----------------------------------------------------------------------------------------------------------------------

Ui::Ui(u32* img, Memory& memory, Z80& z80, Io& io)
    : m_image(img)
    , m_pixels(kUiWidth / 8 * kUiHeight)
    , m_attrs(kUiWidth / 8 * kUiHeight / 8)
    , m_memory(memory)
    , m_z80(z80)
    , m_io(io)
{

}

void Ui::clear()
{
    m_pixels.assign(kUiWidth / 8 * kUiHeight, 0x00);
    m_attrs.assign(kUiWidth / 8 * kUiHeight / 8, 0x00);
}

void Ui::render(std::function<void(Ui::Draw &)> draw)
{
    static const u32 colours[16] =
    {
        0xff000000, 0xffd70000, 0xff0000d7, 0xffd700d7, 0xff00d700, 0xffd7d700, 0xff00d7d7, 0xffd7d7d7,
        0xff000000, 0xffff0000, 0xff0000ff, 0xffff00ff, 0xff00ff00, 0xffffff00, 0xff00ffff, 0xffffffff,
    };

    Draw d(m_pixels, m_attrs);
    draw(d);

    // Convert the pixels and attrs into an image
    u32* img = m_image;
    for (int row = 0; row < kUiHeight; ++row)
    {
        u8* attrRow = m_attrs.data() + ((row >> 3) * (kUiWidth >> 3));
        u8* pixelRow = m_pixels.data() + (row * (kUiWidth >> 3));

        for (int col = 0; col < kUiWidth / 8; ++col)
        {
            u8 p = *pixelRow++;
            u8 a = *attrRow++;

            if (0 == a)
            {
                for (int bit = 0; bit < 8; ++bit) *img++ = 0x00000000;
            }
            else
            {
                u8 ink = a & 0x07;
                u8 paper = (a & 0x38) >> 3;
                u8 bright = (a & 0x40) >> 3;

                for (int bit = 0; bit < 8; ++bit)
                {
                    *img++ = (p & 0x80) != 0 ? colours[ink + bright] : colours[paper + bright];
                    p <<= 1;
                }
            }
        }
    }
}

//----------------------------------------------------------------------------------------------------------------------
// Draw
//----------------------------------------------------------------------------------------------------------------------

Ui::Draw::Draw(std::vector<u8>& pixels, std::vector<u8>& attr)
    : m_pixels(pixels)
    , m_attrs(attr)
{

}

void Ui::Draw::pokePixel(int xCell, int yPixel, u8 bits)
{
    assert(xCell < (kUiWidth / 8));
    assert(yPixel < kUiHeight);
    m_pixels[yPixel * (kUiWidth / 8) + xCell] = bits;
}

void Ui::Draw::andPixel(int xCell, int yPixel, u8 bits)
{
    assert(xCell < (kUiWidth / 8));
    assert(yPixel < kUiHeight);
    m_pixels[yPixel * (kUiWidth / 8) + xCell] &= bits;
}

void Ui::Draw::orPixel(int xCell, int yPixel, u8 bits)
{
    assert(xCell < (kUiWidth / 8));
    assert(yPixel < kUiHeight);
    m_pixels[yPixel * (kUiWidth / 8) + xCell] |= bits;
}

void Ui::Draw::xorPixel(int xCell, int yPixel, u8 bits)
{
    assert(xCell < (kUiWidth / 8));
    assert(yPixel < kUiHeight);
    m_pixels[yPixel * (kUiWidth / 8) + xCell] ^= bits;
}

void Ui::Draw::pokeAttr(int xCell, int yCell, u8 attr)
{
    assert(xCell < (kUiWidth / 8));
    assert(yCell < (kUiHeight / 8));
    m_attrs[yCell * (kUiWidth / 8) + xCell] = attr;
}

void Ui::Draw::printChar(int xCell, int yCell, char c, u8 attr, const u8* font = gFont)
{
    if (c < 32 || c > 127) c = 32;
    pokeAttr(xCell, yCell, attr);
    const u8* pixels = &font[(c - ' ') * 8];
    for (int i = 0; i < 8; ++i)
    {
        pokePixel(xCell, yCell * 8 + i, *pixels++);
    }
}

int Ui::Draw::printChar(int xPixel, int yCell, char c, const u8* font = gFont)
{
    if (xPixel < 0 || xPixel >= kUiWidth) return 0;
    if (yCell < 0 || yCell >= kUiHeight) return 0;
    if (c < 32 || c > 127) c = 32;
    const u8* pixels = &font[(c - ' ') * 8];
    u8 mask = 0;
    int rShift = xPixel % 8;
    int lShift = 0;
    int cx = xPixel / 8;
    int y = yCell * 8;

    // Prepare the mask by ORing all the bytes.
    // If the mask is blank (i.e. a space), create one of width 6.
    for (int i = 0; i < 8; ++i) mask |= pixels[i];
    if (0 == mask) mask = 0xfc;

    // Make sure there is only 1 pixel at most to the left of the mask
    for (u8 b = 0xc0; ((mask << lShift) & b) == 0; ) ++lShift;

    for (int i = 0; i < 8; ++i)
    {
        u16 m = ~(mask << (8 - rShift + lShift));
        u16 w = (*pixels++ << (8 - rShift + lShift));
        andPixel(cx, y + i, HI(m));
        orPixel(cx, y + i, HI(w));
        if ((rShift != 0) && ((xPixel + 8) < kUiWidth))
        {
            andPixel(cx + 1, y + i, LO(m));
            orPixel(cx + 1, y + i, LO(w));
        }
    }

    // Calculate the width of the character
    int width = 8 - lShift;
    if (0 == mask)
    {
        // Space was found
        width = 6;
    }
    else while ((mask & 1) == 0)
    {
        --width;
        mask >>= 1;
    }

    return width;
}

void Ui::Draw::printString(int xCell, int yCell, const char* str, u8 attr, const u8* font = gFont)
{
    for (; *str != 0; ++str)
    {
        printChar(xCell++, yCell, *str, attr, font);
        if (xCell >= (kUiWidth / 8))
        {
            ++yCell;
            xCell = 0;
            if (yCell >= (kUiHeight / 8)) return;
        }
    }
}

void Ui::Draw::printSquashedString(int xCell, int yCell, const char* str, u8 attr, const u8* font = gFont)
{
    int maxWidth = 0;
    int x = xCell * 8;
    for (; *str != 0; ++str)
    {
        int w = printChar(x, yCell, *str, font);
        maxWidth += w;
        x += w;
    }

    // Render the attributes as best we can
    int len = maxWidth / 8 + (maxWidth % 8 ? 1 : 0);
    for (int i = xCell; i < std::min(kUiWidth / 8, xCell + len); ++i)
    {
        pokeAttr(i, yCell, attr);
    }
}

//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------

#endif // NX_IMPL
