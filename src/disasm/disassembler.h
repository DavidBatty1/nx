//----------------------------------------------------------------------------------------------------------------------
// Disassembler document
//----------------------------------------------------------------------------------------------------------------------

#pragma once

#include <config.h>
#include <types.h>
#include <asm/asm.h>
#include <emulator/spectrum.h>

//----------------------------------------------------------------------------------------------------------------------
// DisassemblerDoc
//
// Command format:
//
//  Type            Line                Param1                              Text
//
//  FullComment     Insert point        Command index inserting before      Comment text
//  LineComment     Instruction pos     Command index generated code        Comment text
//  CodeEntry       Range line          -                                   -
//----------------------------------------------------------------------------------------------------------------------

class DisassemblerDoc
{
public:
    DisassemblerDoc(Spectrum& speccy);

    bool load(Spectrum& speccy, string fileName);
    bool save(string fileName);
    bool hasChanged() const { return m_changed; }

    void onKey(sf::Keyboard::Key key, bool down, bool shift, bool ctrl, bool alt);
    void onText(char ch);

    int getNumLines() const { return (int)m_lines.size(); }
    int deleteLine(int line);

    //
    // Lines
    // Used for rendering and generated from commands via processCommand() function.
    //
    enum class LineType
    {
        Blank,              // Blank Line
        UnknownRange,       // Unknown range of memory
        FullComment,        // Line-based comment
        Label,
        Instruction,
    };

    struct Line
    {
        LineType    type;
        int         commandIndex;   // Index of command that generated this line
        MemAddr     startAddress;
        MemAddr     endAddress;
        string      text;

        Line(LineType type, int commandIndex, MemAddr start, MemAddr end, string text)
            : type(type)
            , commandIndex(commandIndex)
            , startAddress(start)
            , endAddress(end)
            , text(move(text))
        {}
    };

    const Line& getLine(int i) const { return m_lines[i]; }
    Line& getLine(int i) { return m_lines[i]; }

    void insertLine(int i, Line line) { m_lines.insert(m_lines.begin() + i, line); }

    //
    // Commands
    //

    enum class CommandType
    {
        FullComment,        // Insert a full comment
        LineComment,        // Comment next to a line
        CodeEntry,          // Insert a code entry point
    };

    struct Command
    {
        CommandType     type;       // Type of command
        int             line;       // Line target of lines generated by previous commands
        MemAddr         addr;       // Associated address
        string          text;       // Associated text

        Command(CommandType type, int line, MemAddr addr, string text)
            : type(type)
            , line(line)
            , addr(addr)
            , text(move(text))
        {}
    };

    bool processCommand(CommandType type, int line, MemAddr addr, string text = {});
    void setText(int commandIndex, string text);
    int getCommandIndex(int line) const;

private:
    //
    // Internal API
    //

    void reset(const Spectrum& speccy);
    void changed() { m_changed = true; }
    optional<int> findLine(MemAddr addr) const;

private:
    vector<u8>          m_mmap;         // Snapshot of memory
    vector<Command>     m_commands;
    bool                m_changed;

    //
    // Internal database generated from processing commands
    //
    vector<Line>        m_lines;
};
